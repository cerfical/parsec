#ifndef PARSEC_REG_EX_NODES_HEADER
#define PARSEC_REG_EX_NODES_HEADER

#include "Utils.hpp"

#include <ostream>
#include <memory>
#include <vector>

namespace parsec {
	class RegExTraverser;
	class RegExChar;

	/** @brief List of pointers to @ref RegExChar "RegExChars". */
	using RegExCharList = std::vector<const RegExChar*>;

	/**
	 * @brief Polymorphic entry point to the tree representation of a regular expression.
	 */
	class RegExNode {
	public:
		/** @brief Print out a node to a @c std::ostream. */
		friend std::ostream& operator<<(std::ostream& out, const RegExNode& n);

		/** @{ */
		RegExNode() = default;
		virtual ~RegExNode() = default;
		/** @} */

		/** @{ */
		RegExNode(const RegExNode&) = delete;
		RegExNode& operator=(const RegExNode&) = delete;
		/** @} */

		/** @{ */
		RegExNode(RegExNode&&) = delete;
		RegExNode& operator=(RegExNode&&) = delete;
		/** @} */

		/** @{ */
		/** @brief Traverse the regex tree in a type-safe manner using the RegExTraverser. */
		virtual void TraverseWith(RegExTraverser& traverser) const = 0;

		/** @brief Check if the node can generate an empty string. */
		virtual bool IsNullable() const noexcept = 0;

		/** @brief Make the exact copy of the node. */
		virtual std::unique_ptr<RegExNode> Clone() const = 0;
		/** @} */

		/** @{ */
		/** @brief Set a new parent node. */
		void SetParent(const RegExNode* parent) noexcept {
			m_parent = parent; 
		}

		/** @brief Parent node. */
		const RegExNode* GetParent() const noexcept {
			return m_parent;
		}
		/** @} */

		/** @{ */
		/** @brief List of @ref RegExChar "RegExChars" that can take the first position in the string generated by the node. */
		RegExCharList GetFirstPos() const;
		
		/** @brief List of @ref RegExChar "RegExChars" that can take the last position in the string generated by the node. */
		RegExCharList GetLastPos() const;
		/** @} */

		/** @{ */
		/** @brief String representation of the node. */
		std::string ToStr() const;
		/** @} */

	private:
		const RegExNode* m_parent = nullptr;
	};



	/**
	 * @brief Literal character regular expression.
	 */
	class RegExChar : public RegExNode {
	public:
		/** @{ */
		/** @brief Construct a new RegExChar node with a value. */
		explicit RegExChar(char value) noexcept
		 : m_value(value)
		{ }
		/** @} */

		/** @{ */
		void TraverseWith(RegExTraverser& traverser) const override;

		bool IsNullable() const noexcept override {
			return false;
		}

		std::unique_ptr<RegExNode> Clone() const override {
			return std::make_unique<RegExChar>(GetValue());
		}
		/** @} */

		/** @{ */
		/** @brief Value of the character literal. */
		char GetValue() const noexcept {
			return m_value;
		}

		/** @brief List of RegExChar nodes that can take the position after this node. */
		RegExCharList GetFollowPos() const;
		/** @} */

	private:
		char m_value;
	};



	/**
	 * @brief Empty regular expression.
	 */
	class RegExNil : public RegExNode {
	public:
		/** @{ */
		void TraverseWith(RegExTraverser& traverser) const override;

		bool IsNullable() const noexcept override {
			return true;
		}
		
		std::unique_ptr<RegExNode> Clone() const override {
			return std::make_unique<RegExNil>();
		}
		/** @} */
	};



	/**
	 * @brief Unary regex operator.
	 */
	class RegExUnary : public RegExNode {
	public:
		/** @{ */
		/** @brief Construct a new RegExUnary node with a single inner expression. */
		explicit RegExUnary(std::unique_ptr<RegExNode> inner) noexcept
		 : m_inner(std::move(inner)) {
			m_inner->SetParent(this);
		}
		/** @} */

		/** @{ */
		/** @brief Inner expression. */
		const RegExNode* GetInnerExpr() const noexcept {
			return m_inner.get();
		}
		/** @} */
		
	protected:
		/** @{ */
		/** @brief Auxiliary function to clone instances of RegExUnary subclasses. */
		template <typename Node>
		std::unique_ptr<Node> Clone() const {
			return std::make_unique<Node>(GetInnerExpr()->Clone());
		}
		/** @} */

	private:
		std::unique_ptr<RegExNode> m_inner;
	};



	/**
	 * @brief Optional regular expression.
	 */
	class RegExOpt : public RegExUnary {
	public:
		/** @{ */
		/** @brief Construct a new RegExOpt node with a single inner expression. */
		explicit RegExOpt(std::unique_ptr<RegExNode> inner) noexcept
		 : RegExUnary(std::move(inner))
		{ }
		/** @} */

		/** @{ */
		void TraverseWith(RegExTraverser& traverser) const override;

		bool IsNullable() const noexcept override {
			return true;
		}

		std::unique_ptr<RegExNode> Clone() const override {
			return RegExUnary::Clone<RegExOpt>();
		}
		/** @} */
	};



	/**
	 * @brief Kleene plus expression.
	 */
	class RegExPlus : public RegExUnary {
	public:
		/** @{ */
		/** @brief Construct a new RegExPlus node with a single inner expression. */
		explicit RegExPlus(std::unique_ptr<RegExNode> inner) noexcept
		 : RegExUnary(std::move(inner))
		{ }
		/** @} */

		/** @{ */
		void TraverseWith(RegExTraverser& traverser) const override;

		bool IsNullable() const noexcept override {
			return false;
		}

		std::unique_ptr<RegExNode> Clone() const override {
			return RegExUnary::Clone<RegExPlus>();
		}
		/** @} */
	};



	/**
	 * @brief Kleene star expression.
	 */
	class RegExStar : public RegExUnary {
	public:
		/** @{ */
		/** @brief Construct a new RegExStar node with a single inner expression. */
		explicit RegExStar(std::unique_ptr<RegExNode> inner) noexcept
		 : RegExUnary(std::move(inner))
		{ }
		/** @} */

		/** @{ */
		void TraverseWith(RegExTraverser& traverser) const override;

		bool IsNullable() const noexcept override {
			return true;
		}

		std::unique_ptr<RegExNode> Clone() const override {
			return RegExUnary::Clone<RegExStar>();
		}
		/** @} */
	};



	/**
	 * @brief Binary regex operator.
	 */
	class RegExBinary : public RegExNode {
	public:
		/** @{ */
		/** @brief Construct a new RegExBinary node with two subexpressions. */
		RegExBinary(std::unique_ptr<RegExNode> left, std::unique_ptr<RegExNode> right) noexcept
		 : m_left(std::move(left)), m_right(std::move(right)) {
			m_left->SetParent(this);
			m_right->SetParent(this);
		}
		/** @} */

		/** @{ */
		/** @brief Left subexpression. */
		const RegExNode* GetLeftExpr() const noexcept {
			return m_left.get();
		}

		/** @brief Right subexpression. */
		const RegExNode* GetRightExpr() const noexcept {
			return m_right.get();
		}
		/** @} */

	protected:
		/** @{ */
		/** @brief Auxiliary function to clone instances of RegExBinary subclasses. */
		template <typename Node>
		std::unique_ptr<Node> Clone() const {
			return std::make_unique<Node>(GetLeftExpr()->Clone(), GetRightExpr()->Clone());
		}
		/** @} */

	private:
		std::unique_ptr<RegExNode> m_left, m_right;
	};



	/**
	 * @brief Alternation expression.
	 */
	class RegExAltern : public RegExBinary {
	public:
		/** @{ */
		/** @brief Construct a new RegExAltern node with two subexpressions. */
		RegExAltern(std::unique_ptr<RegExNode> left, std::unique_ptr<RegExNode> right) noexcept
		 : RegExBinary(std::move(left), std::move(right))
		{ }
		/** @} */

		/** @{ */
		void TraverseWith(RegExTraverser& traverser) const override;

		bool IsNullable() const noexcept override {
			return GetLeftExpr()->IsNullable() || GetRightExpr()->IsNullable();
		}

		std::unique_ptr<RegExNode> Clone() const override {
			return RegExBinary::Clone<RegExAltern>();
		}
		/** @} */
	};



	/**
	 * @brief Concatenation expression.
	 */
	class RegExConcat : public RegExBinary {
	public:
		/** @{ */
		/** @brief Construct a new RegExConcat node with two subexpressions. */
		RegExConcat(std::unique_ptr<RegExNode> left, std::unique_ptr<RegExNode> right) noexcept
		 : RegExBinary(std::move(left), std::move(right))
		{ }
		/** @} */

		/** @{ */
		void TraverseWith(RegExTraverser& traverser) const override;
		
		bool IsNullable() const noexcept override {
			return GetLeftExpr()->IsNullable() && GetRightExpr()->IsNullable();
		}

		std::unique_ptr<RegExNode> Clone() const override {
			return RegExBinary::Clone<RegExConcat>();
		}
		/** @} */
	};



	/**
	 * @brief Provides a mechanism for traversing regular expressions using the visitor pattern.
	 */
	class RegExTraverser {
	public:
		/** @{ */
		/** @brief Called for a RegExChar node. */
		virtual void VisitNode(const RegExChar& n) = 0;

		/** @brief Called for a RegExOpt node. */
		virtual void VisitNode(const RegExOpt& n) = 0;

		/** @brief Called for a RegExNil node. */
		virtual void VisitNode(const RegExNil& n) = 0;

		/** @brief Called for a RegExPlus node. */
		virtual void VisitNode(const RegExPlus& n) = 0;

		/** @brief Called for a RegExStar node. */
		virtual void VisitNode(const RegExStar& n) = 0;

		/** @brief Called for a RegExAltern node. */
		virtual void VisitNode(const RegExAltern& n) = 0;

		/** @brief Called for a RegExConcat node. */
		virtual void VisitNode(const RegExConcat& n) = 0;
		/** @} */

	protected:
		/** @{ */
		~RegExTraverser() = default;
		/** @} */
	};
}

#endif