#ifndef PARSEC_REGEX_EXPR_NODE_HEADER
#define PARSEC_REGEX_EXPR_NODE_HEADER

#include <string>
#include <vector>
#include <ostream>

namespace parsec::regex {
	class Traverser;
	class CharLiteral;

	/** @brief List of pointers to @ref CharLiteral "CharLiterals". */
	using CharLiteralList = std::vector<const CharLiteral*>;

	/**
	 * @brief Polymorphic entry point to the tree representation of a regular expression.
	 */
	class ExprNode {
	public:
		/** @{ */
		/** @brief Print out a node to a @c std::ostream. */
		friend std::ostream& operator<<(std::ostream& out, const ExprNode& n);
		/** @} */


		/** @{ */
		/** @brief Default initialize the node. */
		ExprNode() = default;

		virtual ~ExprNode() = default;
		/** @} */


		/** @{ */
		ExprNode(const ExprNode&) = delete;
		ExprNode& operator=(const ExprNode&) = delete;
		/** @} */

		/** @{ */
		ExprNode(ExprNode&&) = delete;
		ExprNode& operator=(ExprNode&&) = delete;
		/** @} */


		/** @{ */
		/** @brief Traverse the regex tree in a type-safe manner using the Traverser. */
		virtual void traverseWith(Traverser& traverser) const = 0;

		/** @brief Check if the node can generate an empty string. */
		virtual bool nullable() const noexcept = 0;
		/** @} */


		/** @{ */
		/** @brief Set the new parent node. */
		void setParent(const ExprNode* parent) noexcept {
			m_parent = parent;
		}

		/** @brief Parent node. */
		const ExprNode* parent() const noexcept {
			return m_parent;
		}
		/** @} */


		/** @{ */
		/** @brief Find the nodes that can take the first position in the string generated by the node. */
		CharLiteralList computeFirstPos() const;

		/** @brief Find the nodes that can take the last position in the string generated by the node. */
		CharLiteralList computeLastPos() const;
		/** @} */


		/** @{ */
		/** @brief Retrieve the string representation of the node. */
		std::string toStr() const;
		/** @} */

	private:
		const ExprNode* m_parent = nullptr;
	};
}

#endif