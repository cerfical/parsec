#ifndef PARSEC_REGEX_NODES_HEADER
#define PARSEC_REGEX_NODES_HEADER

#include "Utils.hpp"

#include <iostream>
#include <memory>
#include <vector>

namespace parsec {
	class RegExTraverser;
	class RegExChar;

	/** @brief List of pointers to @ref RegExChar "RegExChars". */
	using RegExCharList = std::vector<const RegExChar*>;

	/**
	 * @brief Polymorphic entry point to the tree representation of a regular expression.
	 */
	class RegExNode {
	public:
		/** @brief Print out the node to a @c std::ostream. */
		friend std::ostream& operator<<(std::ostream& out, const RegExNode& regex);

		/** @{ */
		RegExNode(const RegExNode&) = delete;
		RegExNode& operator=(const RegExNode&) = delete;
		/** @} */

		/** @{ */
		RegExNode(RegExNode&&) = delete;
		RegExNode& operator=(RegExNode&&) = delete;
		/** @} */

		/** @{ */
		/** @copybrief */
		virtual ~RegExNode() = default;
		/** @} */

		/** @{ */
		/** @brief Traverse the regex tree in a type-safe manner using the specified RegExTraverser. */
		virtual void TraverseWith(RegExTraverser& traverser) const = 0;

		/** @brief Check if the node can generate an empty string. */
		virtual bool IsNullable() const noexcept = 0;
		/** @} */

		/** @{ */
		/** @brief Set a new parent for the node. */
		void SetParent(const RegExNode* parent) noexcept {
			this->parent = parent; 
		}

		/** @brief Get the parent of the node. */
		const RegExNode* GetParent() const noexcept {
			return parent;
		}
		/** @} */

		/** @{ */
		/** @brief Make the list of @ref RegExChar "RegExChars" that can take the first position in the string generated by the node. */
		RegExCharList GetFirstPos() const;
		
		/** @brief Make the list of @ref RegExChar "RegExChars" that can take the last position in the string generated by the node. */
		RegExCharList GetLastPos() const;
		/** @} */

	protected:
		/** @copybrief */
		RegExNode() = default;

	private:
		const RegExNode* parent = nullptr;
	};



	/**
	 * @brief Literal character regular expression.
	 */
	class RegExChar : public RegExNode {
	public:
		/** @{ */
		/** @brief Construct a new character literal from its value. */
		explicit RegExChar(char value) noexcept
		 : value(value)
		{ }

		/** @copybrief */
		~RegExChar() = default;
		/** @} */

		/** @{ */
		void TraverseWith(RegExTraverser& traverser) const override;

		bool IsNullable() const noexcept override {
			return false;
		}
		/** @} */

		/** @{ */
		/** @brief Get the value of the character literal. */
		char GetValue() const noexcept {
			return value;
		}

		/** @brief Make the list of @ref RegExChar "RegExChars" that can take the position next to the character. */
		RegExCharList GetFollowPos() const;
		/** @} */

	private:
		char value;
	};



	/**
	 * @brief Kleene star expression.
	 */
	class RegExStar : public RegExNode {
	public:
		/** @{ */
		/** @brief Construct a new RegExStar from its inner expression. */
		explicit RegExStar(std::unique_ptr<RegExNode> expr) noexcept
		 : innerExpr(std::move(expr)) {
			innerExpr->SetParent(this);
		}

		/** @copybrief */
		~RegExStar() = default;
		/** @} */

		/** @{ */
		void TraverseWith(RegExTraverser& traverser) const override;

		bool IsNullable() const noexcept override {
			return true;
		}
		/** @} */

		/** @{ */
		/** @brief Get the inner expression of the RegExStar. */
		const RegExNode& GetInnerExpr() const noexcept {
			return *innerExpr;
		}
		/** @} */
		
	private:
		std::unique_ptr<RegExNode> innerExpr;
	};



	/**
	 * @brief Alternation expression.
	 */
	class RegExAltern : public RegExNode {
	public:
		/** @{ */
		/** @brief Construct a new RegExAltern from its subexpressions. */
		RegExAltern(std::unique_ptr<RegExNode> left, std::unique_ptr<RegExNode> right) noexcept
		 : leftExpr(std::move(left)), rightExpr(std::move(right)) {
			leftExpr->SetParent(this);
			rightExpr->SetParent(this);
		}

		/** @copybrief */
		~RegExAltern() = default;
		/** @} */

		/** @{ */
		void TraverseWith(RegExTraverser& traverser) const override;

		bool IsNullable() const noexcept override {
			return leftExpr->IsNullable() || rightExpr->IsNullable();
		}
		/** @} */

		/** @{ */
		/** @brief Get the left subexpression of the RegExAltern. */
		const RegExNode& GetLeftExpr() const noexcept {
			return *leftExpr;
		}

		/** @brief Get the right subexpression of the RegExAltern. */
		const RegExNode& GetRightExpr() const noexcept {
			return *rightExpr;
		}
		/** @} */

	private:
		std::unique_ptr<RegExNode> leftExpr, rightExpr;
	};



	/**
	 * @brief Concatenation expression.
	 */
	class RegExConcat : public RegExNode {
	public:
		/** @{ */
		/** @brief Construct a RegExConcat from its two subexpressions. */
		RegExConcat(std::unique_ptr<RegExNode> left, std::unique_ptr<RegExNode> right) noexcept
		 : leftExpr(std::move(left)), rightExpr(std::move(right)) {
			leftExpr->SetParent(this);
			rightExpr->SetParent(this);
		}

		/** @copybrief */
		~RegExConcat() = default;
		/** @} */

		/** @{ */
		void TraverseWith(RegExTraverser& traverser) const override;
		
		bool IsNullable() const noexcept override {
			return leftExpr->IsNullable() && rightExpr->IsNullable();
		}
		/** @} */

		/** @{ */
		/** @brief Get the left subexpression of the RegExConcat. */
		const RegExNode& GetLeftExpr() const noexcept {
			return *leftExpr;
		}

		/** @brief Get the right subexpression of the RegExConcat. */
		const RegExNode& GetRightExpr() const noexcept {
			return *rightExpr;
		}
		/** @} */

	private:
		std::unique_ptr<RegExNode> leftExpr, rightExpr;
	};



	/**
	 * @brief Provides a mechanism for traversing regular expressions using the visitor pattern.
	 */
	class RegExTraverser {
	public:
		/** @{ */
		/** @brief Called for a RegExChar node. */
		virtual void VisitNode(const RegExChar& n) = 0;

		/** @brief Called for a RegExStar node. */
		virtual void VisitNode(const RegExStar& n) = 0;

		/** @brief Called for a RegExAltern node. */
		virtual void VisitNode(const RegExAltern& n) = 0;

		/** @brief Called for a RegExConcat node. */
		virtual void VisitNode(const RegExConcat& n) = 0;
		/** @} */

		/** @{ */
		/** @brief Defines the order in which the traverser visits child nodes. */
		virtual TraversalTypes GetTraversalType() const noexcept {
			return TraversalTypes::None;
		} 
		/** @} */

	protected:
		/** @{ */
		/** @copybrief */
		RegExTraverser() = default;

		/** @copybrief */
		~RegExTraverser() = default;
		/** @} */

		/** @{ */
		RegExTraverser(const RegExTraverser&) = default;
		RegExTraverser& operator=(const RegExTraverser&) = default;
		/** @} */

		/** @{ */
		RegExTraverser(RegExTraverser&&) = default;
		RegExTraverser& operator=(RegExTraverser&&) = default;
		/** @} */
	};
}

#endif